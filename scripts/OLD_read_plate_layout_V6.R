# Parse and graph Revvity XML plate assay definition.
# should work with any user defined parameters
# and any plate types are these are not hard coded

lib2load <- c("here", "xml2", "tidyverse", "gridExtra")
lapply(lib2load, library, character.only = TRUE)

rm(list = ls())

# The XML to be treated
xml_file <- "2577f4a7-3b8f-4c5c-aece-cda68e3d69c7.xml"


# Load the XML; here() gives github/R directory structure consistency
# need to clean the toxic Revvity declarations
# Rem: Couldn't get  specs from Revvity www
path_file <- here("data", xml_file)
xml_text <- readLines(path_file, warn = FALSE)  # Read as text rather that XML parse
xml_text_clean <- gsub('xmlns="[^"]+"', '', xml_text) # forcefully remove "xmlns=..." that kills xms2


# XML2 parse the cleaned XML.
xml_data <- read_xml(paste(xml_text_clean, collapse = "\n"))

# Extract all well nodes
wells <- xml_find_all(xml_data, "//Well")

# Convert row numbers to letters
row_map <- setNames(LETTERS[1:8], 1:8)

# Extract all unique ContentIDs (IDs are user defined when layout is created on Harmony)
content_ids <- xml_find_all(xml_data, "//Content") %>%
  xml_attr("ContentID") %>%
  unique() %>%
  na.omit() # for some reason a NA element in generated by xml_find_all()

# Map-Parse well information into a tibble
plate_data <- map_df(wells, function(well) {
  well_id <- xml_attr(well, "WellID")
  row_num <- as.integer(xml_attr(well, "Row"))
  col_num <- as.integer(xml_attr(well, "Column"))
  
  # Dynamically extract all ContentID values
  content_values <- map(content_ids, function(content_id) {
    value_node <- xml_find_first(well, sprintf(".//Content[@ContentID='%s']/Value", content_id))
    if (!is.na(value_node)) {
      xml_text(value_node) # Get the parameter value at the node
    } else {
      NA_character_  # Required somehow... May be improved (How?)
    }
  })

  # Create a named list for the content values
  names(content_values) <- content_ids #  a named list
  # print(content_values)
  
  # Combine with well information
  tibble(
    WellID = well_id,
    Row = row_map[as.character(row_num)],  # Convert row numbers to letters
    Column = col_num,
    !!!content_values  #  splice the named list into the tibble
  )
})

# Does "NA_character_" exists? test no longer required as na.omit() is used above
if ("NA_character_" %in% colnames(plate_data)) {
  plate_data[["NA_character_"]] <- NULL  # Remove the column using double brackets
  cat("La colonne 'NA_character_' a été supprimée du data frame.\n")
} else {
  cat("La colonne 'NA_character_' n'existe pas dans le data frame.\n")
}

 print(plate_data)

# Function to plot grid for a given variable
plot_plate <- function(data, variable, title) {
  
  ggplot(data, aes(x = Column, y = Row, fill = .data[[variable]])) +
    geom_tile(color = "black") +
    scale_y_discrete(limits = rev(LETTERS[1:8])) +  # Ensure A is at the top
    scale_x_continuous(breaks = 1:12) +
    labs(title = title, x = "Column", y = "Row") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 10, angle = 0),
      axis.text.y = element_text(size = 10),
      legend.title = element_blank()
    )
}

# Plot each variable
plots <- map(content_ids, function(content_id) {
  tryCatch({
    plot_plate(plate_data, content_id, sprintf("Plate Layout - %s", content_id))
  }, error = function(e) {
    message(sprintf("Skipping plot for '%s': %s", content_id, e$message))
    NULL  # Skip plotting if there's an error
  })
})

# Remove NULL plots (those that failed), if any
plots <- Filter(Negate(is.null), plots)
do.call(grid.arrange, c(plots, ncol = 1))
